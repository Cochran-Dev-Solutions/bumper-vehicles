import { PhysicsWorld } from '../physics/PhysicsWorld.js';
import { PlayerEntity } from '../game_entities/PlayerEntity.js';
import mapManager from './Map.js';
import { Vec2 } from '../utils/vector.js';

export default class Game {
  constructor(config) {
    this.physicsWorld = new PhysicsWorld();
    this.type = config.type; // 'race' or 'battle'
    this.mapName = config.mapName || mapManager.getDefaultMap(this.type);
    this.state = 'waiting'; // 'waiting', 'playing', or 'inactive'
    // players to be sent to the front-end
    this.players = new Map();

    // non-player-actors: passive actors that have no controls, but have position and size data
    this.passive_actors = [];

    this.actor_lists = {};

    this.disconnectedPlayers = new Map();
    this.reconnect_timeout = 6000; // 6 seconds to reconnect
    this.passiveActorIdCounter = 0;
    this.changed_actors = new Set();
    this.spawn_points = []; // Will store available spawn points
    this.taken_spawn_points = new Map(); // Maps player ID to spawn point index

    // Set up the game immediately
    this.setup();
  }

  /**
   * Generate a unique passive actor ID
   * @returns {string} Unique passive actor ID
   */
  generatePassiveActorId() {
    return `actor_${this.passiveActorIdCounter++}`;
  }

  /**
   * Set up the game environment
   */
  setup() {
    // Load the map script
    const script = mapManager.getMapScript('race', this.mapName);
    if (!script) {
      console.error(`Failed to load map script for ${this.mapName}`);
      return;
    }

    // Second pass: create other entities
    script.forEach((instruction) => {
      if (instruction.type === 'spawn_point') {
        this.spawn_points.push(instruction.parameters.position);
        return;
      }

      const EntityConstructor = mapManager.getConstructor(instruction.type);
      if (EntityConstructor) {
        const entity = new EntityConstructor({
          ...instruction.parameters,
          id: this.generatePassiveActorId(),
          tileMap: this.physicsWorld.tileMap,
          game: this
        });
        if (entity.hasUpdate) {
          this.physicsWorld.addEntity(entity);
        }
        this.passive_actors.push(entity);
      }
    });

    // Set required players based on number of spawn points
    this.requiredPlayers = this.spawn_points.length;
  }

  /**
   * Get a random spawn point and mark it as taken
   * @returns {Object|null} Object containing position and index, or null if no spawn points available
   */
  getRandomSpawnPoint() {
    // Find available spawn points (not in taken_spawn_points)
    const availableSpawnPoints = this.spawn_points.filter((_, index) =>
      !Array.from(this.taken_spawn_points.values()).includes(index)
    );

    if (availableSpawnPoints.length === 0) {
      console.error('No spawn points available');
      return null;
    }

    const randomIndex = Math.floor(Math.random() * availableSpawnPoints.length);
    const spawnPoint = availableSpawnPoints[randomIndex];

    // Find the original index in spawn_points array
    const originalIndex = this.spawn_points.indexOf(spawnPoint);

    return { position: spawnPoint, index: originalIndex };
  }

  /**
   * Add a player to the game
   * @param {string} socketId - Socket ID of the player
   * @param {Object} userData - User data for the player
   * @param {string} playerId - Unique player ID generated by the server
   * @returns {Object} Object containing the player and whether the game should start
   */
  addPlayer(socketId, userData, playerId) {
    const spawnData = this.getRandomSpawnPoint();
    if (!spawnData) {
      console.error('Cannot add player: no spawn points available');
      return null;
    }

    const player = new PlayerEntity({
      position: spawnData.position,
      radius: 25,
      socketId: socketId,
      id: playerId,  // Use the provided playerId instead of generating one
      tileMap: this.physicsWorld.tileMap,
      game: this,
      userData: userData
    });

    // Mark spawn point as taken
    this.taken_spawn_points.set(player.id, spawnData.index);

    this.players.set(socketId, player);
    this.physicsWorld.addEntity(player);

    const shouldStartGame = this.players.size >= this.requiredPlayers;
    return { player, shouldStartGame };
  }

  handleDisconnect(socketId, io) {
    const player = this.players.get(socketId);
    if (player) {
      player.disconnected = true;
      this.disconnectedPlayers.set(player.id, player);

      // Set timeout to remove player after 6 seconds if they haven't reconnected
      setTimeout(() => {
        // Check if player is still disconnected
        if (player.disconnected) {
          console.log(`Player ${player.id} timed out after ${this.reconnect_timeout}ms`);

          // Remove player from game
          this.removePlayer(socketId);

          // Clean up maps
          this.disconnectedPlayers.delete(player.id);

          // Notify all players about the removal
          io.emit('playerRemoved', { playerId: player.id });
        }
      }, this.reconnect_timeout);
    }
  }

  handleReconnect(socketId, playerId) {
    // Find player by playerId instead of socketId
    for (const [oldSocketId, player] of this.players) {
      if (player.id === playerId) {
        // Update the player's socket ID to the new one
        this.players.delete(oldSocketId);
        this.players.set(socketId, player);
        player.disconnected = false;
        player.socketId = socketId;
        this.disconnectedPlayers.delete(playerId);
        return { success: true };
      }
    }
    return { success: false };
  }

  // immediately delete a player from game
  removePlayer(socketId) {
    const player = this.players.get(socketId);
    if (player) {
      // Free up the spawn point
      this.taken_spawn_points.delete(player.id);

      this.physicsWorld.removeEntity(player);
      this.players.delete(socketId);
      if (player.disconnected) {
        this.disconnectedPlayers.delete(player.id);
      }
    }
  }

  getPlayerBySocketId(socketId) {
    return this.players.get(socketId);
  }

  getPlayerByPlayerId(playerId) {
    for (const player of this.players.values()) {
      if (player.id === playerId) {
        return player;
      }
    }
    return null;
  }

  getPlayerCount() {
    return this.players.size;
  }

  isInactive() {
    return this.players.size === 0 && this.disconnectedPlayers.size === 0;
  }

  update(io) {
    // Check if game should be marked as inactive
    if (this.isInactive()) {
      this.state = 'inactive';
      return;
    }

    // Update all players
    this.physicsWorld.update();

    // Send new game state to players
    const newGameState = this.getState();
    this.players.forEach((player, socketId) => {
      io.to(socketId).emit('gameState', newGameState);
    });
  }

  /**
   * Mark an actor as changed
   * @param {Entity} actor - The actor that has changed
   */
  markActorChanged(actor) {
    this.changed_actors.add(actor);
  }

  /**
   * Get state data for all changed actors
   * @returns {Array} Array of actor state data
   */
  getChangedActorsState() {
    const actors = [];

    // Iterate directly over changed actors
    this.changed_actors.forEach(actor => {
      if (actor.socketId) { // It's a player
        actors.push({
          id: actor.id,
          type: 'player',
          x: actor.boundingBox.left,
          y: actor.boundingBox.top,
          width: actor.size.x,
          height: actor.size.y,
          flags: actor.flags
        });
      } else { // It's a passive actor
        actors.push({
          id: actor.id,
          type: actor.type,
          x: actor.boundingBox.left,
          y: actor.boundingBox.top,
          width: actor.size.x,
          height: actor.size.y
        });
      }
    });

    // Clear the changed actors set after getting their state
    this.changed_actors.clear();

    return actors;
  }

  /**
   * Get current game state
   * @returns {Object} Game state data
   */
  getState() {
    return {
      type: this.type,
      actors: this.getChangedActorsState()
    };
  }

  /**
   * Get initial game state
   * @returns {Object} Initial game state data
   */
  getInitialState() {
    return {
      type: this.type,
      players: Array.from(this.players.values()).map(player => ({
        id: player.id,
        x: player.position.x,
        y: player.position.y,
        radius: player.radius,
        flags: player.flags,
        type: 'player'
      })),
      passive_actors: this.passive_actors.map(actor => ({
        id: actor.id,
        type: actor.type,
        type_of_actor: actor.type_of_actor,
        x: actor.position.x,
        y: actor.position.y,
        width: actor.size.x,
        height: actor.size.y
      }))
    };
  }

  start(io) {
    // broadcast initial game state
    this.players.forEach((player, socketId) => {
      console.log(`Sending game setup to player ${player.id} (socket: ${socketId})`);
      io.to(socketId).emit('gameSetup', this.getInitialState());
    });
  }
} 