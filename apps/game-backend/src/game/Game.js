import { PhysicsWorld } from "../physics/PhysicsWorld.js";
import { PlayerEntity } from "../game_entities/PlayerEntity.js";
import mapManager from "./Map.js";
import { TileMap } from "../physics/TileMap.js";

export default class Game {
  constructor(config) {
    this.physicsWorld = new PhysicsWorld();
    this.type = config.type; // 'race' or 'battle' or 'inactive'
    this.mapName = config.mapName || mapManager.getDefaultMap(this.type);
    this.state = "waiting"; // 'waiting', 'playing', or 'inactive'
    // players to be sent to the front-end
    this.players = new Map();

    // non-player-actors: passive actors that have no controls, but have position and size data
    this.passive_actors = [];

    this.actor_lists = {};

    this.disconnectedPlayers = new Map();
    this.reconnect_timeout = 6000; // 6 seconds to reconnect
    this.passiveActorIdCounter = 0;
    this.changed_actors = new Set();
    this.new_actors = new Set(); // Track newly added actors
    this.removed_actors = new Set();
    this.spawn_points = []; // Will store available spawn points
    this.taken_spawn_points = new Map(); // Maps player ID to spawn point index

    // Map dimensions for boundary collision
    this.mapWidth = 0;
    this.mapHeight = 0;

    // Set up the game immediately
    this.setup();
  }

  /**
   * Generate a unique passive actor ID
   * @returns {string} Unique passive actor ID
   */
  generatePassiveActorId() {
    return `actor_${this.passiveActorIdCounter++}`;
  }

  /**
   * Set up the game environment
   */
  setup() {
    // Load the map script
    const mapData = mapManager.getMapScript("race", this.mapName);
    if (!mapData) {
      console.error(`Failed to load map script for ${this.mapName}`);
      return;
    }

    // Set map dimensions from script if available, otherwise calculate them
    if (mapData.dimensions) {
      this.mapWidth = mapData.dimensions.width;
      this.mapHeight = mapData.dimensions.height;
    }

    // Second pass: create other entities
    mapData.entities.forEach(instruction => {
      if (instruction.type === "spawn_point") {
        this.spawn_points.push(instruction.parameters.position);
        return;
      }

      const EntityConstructor = mapManager.getConstructor(instruction.type);
      if (EntityConstructor) {
        const entity = new EntityConstructor({
          ...instruction.parameters,
          id: this.generatePassiveActorId(),
          tileMap: this.physicsWorld.tileMap,
          game: this,
        });
        if (entity.hasUpdate) {
          this.physicsWorld.addEntity(entity);
        }
        this.passive_actors.push(entity);
      }
    });

    // Set required players based on number of spawn points
    this.requiredPlayers = this.spawn_points.length;

    // Calculate map dimensions if not provided in script (for backward compatibility)
    if (!mapData.dimensions) {
      this.calculateMapDimensions();
    }
  }

  /**
   * Get a random spawn point and mark it as taken
   * @returns {Object|null} Object containing position and index, or null if no spawn points available
   */
  getRandomSpawnPoint() {
    // Find available spawn points (not in taken_spawn_points)
    const availableSpawnPoints = this.spawn_points.filter(
      (_, index) =>
        !Array.from(this.taken_spawn_points.values()).includes(index)
    );

    if (availableSpawnPoints.length === 0) {
      console.error("No spawn points available");
      return null;
    }

    const randomIndex = Math.floor(Math.random() * availableSpawnPoints.length);
    const spawnPoint = availableSpawnPoints[randomIndex];

    // Find the original index in spawn_points array
    const originalIndex = this.spawn_points.indexOf(spawnPoint);

    return { position: spawnPoint, index: originalIndex };
  }

  /**
   * Calculate map dimensions based on entity positions
   */
  calculateMapDimensions() {
    let maxX = 0;
    let maxY = 0;

    // Check all passive actors
    this.passive_actors.forEach(actor => {
      const rightEdge =
        actor.position.x + (actor.size ? actor.size.x : actor.radius * 2);
      const bottomEdge =
        actor.position.y + (actor.size ? actor.size.y : actor.radius * 2);

      if (rightEdge > maxX) maxX = rightEdge;
      if (bottomEdge > maxY) maxY = bottomEdge;
    });

    // Add some padding
    this.mapWidth = maxX + 100;
    this.mapHeight = maxY + 100;
  }

  /**
   * Add a player to the game
   * @param {string} socketId - Socket ID of the player
   * @param {Object} userData - User data for the player
   * @param {string} playerId - Unique player ID generated by the server
   * @returns {Object} Object containing the player and whether the game should start
   */
  addPlayer(socket, userData, playerId) {
    const spawnData = this.getRandomSpawnPoint();
    if (!spawnData) {
      console.error("Cannot add player: no spawn points available");
      return null;
    }

    const player = new PlayerEntity({
      position: spawnData.position,
      type: "player",
      radius: TileMap.getGridSize() / 2 - 10,
      socketId: socket.id,
      id: playerId, // Use the provided playerId instead of generating one
      tileMap: this.physicsWorld.tileMap,
      game: this,
      userData: userData,
      socket: socket,
    });

    // Mark spawn point as taken
    this.taken_spawn_points.set(player.id, spawnData.index);

    this.players.set(socket.id, player);
    this.physicsWorld.addEntity(player);

    const shouldStartGame = this.players.size >= this.requiredPlayers;
    return shouldStartGame;
  }

  handleDisconnect(socketId, io) {
    const player = this.players.get(socketId);
    if (player) {
      player.disconnected = true;
      this.disconnectedPlayers.set(player.id, player);

      // Set timeout to remove player after 6 seconds if they haven't reconnected
      setTimeout(() => {
        // Check if player is still disconnected
        if (player.disconnected) {
          console.log(
            `Player ${player.id} timed out after ${this.reconnect_timeout}ms`
          );

          // Notify all players in this game about the removal
          this.players.forEach((_, socketId) => {
            io.to(socketId).emit("playerRemoved", { playerId: player.id });
          });

          // Remove player from game
          this.removePlayer(socketId);
        }
      }, this.reconnect_timeout);
    }
  }

  handleReconnect(socketId, playerId) {
    // Find player by playerId instead of socketId
    for (const [oldSocketId, player] of this.players) {
      if (player.id === playerId) {
        // Update the player's socket ID to the new one
        this.players.delete(oldSocketId);
        this.players.set(socketId, player);
        player.disconnected = false;
        player.socketId = socketId;
        this.disconnectedPlayers.delete(playerId);
        return { success: true };
      }
    }
    return { success: false };
  }

  // delete a player from game
  removePlayer(socketId) {
    const player = this.players.get(socketId);
    if (player) {
      // Free up the spawn point
      this.taken_spawn_points.delete(player.id);

      this.physicsWorld.removeEntity(player);
      this.players.delete(socketId);
      if (player.disconnected) {
        this.disconnectedPlayers.delete(player.id);
      }
    }
  }

  getPlayerBySocketId(socketId) {
    return this.players.get(socketId);
  }

  getPlayerByPlayerId(playerId) {
    for (const player of this.players.values()) {
      if (player.id === playerId) {
        return player;
      }
    }
    return null;
  }

  getPlayerCount() {
    return this.players.size;
  }

  isInactive() {
    return this.players.size === 0 && this.disconnectedPlayers.size === 0;
  }

  update(io) {
    // Check if game should be marked as inactive
    if (this.isInactive()) {
      this.state = "inactive";
      return;
    }

    // Update all players
    this.physicsWorld.update();

    // Send new game state to players
    const newGameState = this.getState();
    this.players.forEach((player, socketId) => {
      io.to(socketId).emit("gameState", newGameState);
    });
  }

  /**
   * Mark an actor as changed
   * @param {Entity} actor - The actor that has changed
   */
  markActorChanged(actor) {
    this.changed_actors.add(actor);
  }

  /**
   * Get state data for all changed actors
   * @returns {Array} Array of actor state data
   */
  getChangedActorsState() {
    const actors = Array.from(this.changed_actors).map(actor =>
      actor.getUpdatedState()
    );
    this.changed_actors.clear();
    return actors;
  }

  /**
   * Mark an actor as new
   * @param {Entity} actor - The actor that is new
   */
  markActorNew(actor) {
    this.new_actors.add(actor);
  }

  /**
   * Get state data for all new actors
   * @returns {Array} Array of new actor state data
   */
  getNewActorsState() {
    const actors = Array.from(this.new_actors).map(actor =>
      actor.getInitialState()
    );
    this.new_actors.clear();
    return actors;
  }

  markActorRemoved(actor) {
    this.removed_actors.add(actor.id);
  }

  getRemovedActorsIds() {
    const actorIds = Array.from(this.removed_actors);
    this.removed_actors.clear();
    return actorIds;
  }

  /**
   * Get current game state
   * @returns {Object} Game state data
   */
  getState() {
    return {
      type: this.type,
      actors: this.getChangedActorsState(),
      new_actors: this.getNewActorsState(),
      removed_actor_ids: this.getRemovedActorsIds(),
    };
  }

  /**
   * Get initial game state
   * @returns {Object} Initial game state data
   */
  getInitialState() {
    return {
      type: this.type,
      players: Array.from(this.players.values()).map(player =>
        player.getInitialState()
      ),
      passive_actors: this.passive_actors.map(actor => actor.getInitialState()),
      mapWidth: this.mapWidth,
      mapHeight: this.mapHeight,
    };
  }

  start(io) {
    // broadcast initial game state
    this.players.forEach((player, socketId) => {
      io.to(socketId).emit("gameSetup", this.getInitialState());
    });
  }
}
